### htttp 定义
它是一种基于请求响应的，无状态的，单向应用层协议。基于TCP/IP协议传输数据。
主要特点：
* 灵活：http传输任意类型数据，通过Content-type标记类型。
* 无状态：指对事物处理没有记忆能力，

### URL
URI：Uniform Resource Identifiers，统一资源标志符。
包括：
1.访问资源的命名机制
2.存放资源的主机名
3.资源自身的名称，由路径表示，着重强调于资源。
URL:全称是Uniform Resource Locator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。

URL与URI区别：
URI用于唯一标识一个资源，URL是一种具体URI，可以标识资源，而且指明如何定位资源。

### Request
请求格式：
请求行，请求头，空行，请求数据。
请求行：
请求类型（GET,POST,...），请求资源路径，协议名（http1.1）。

### Response
响应格式：
响应行，响应头，空行，响应体。

响应头：
#### 通用头部（请求响应都有的）
Cache-Control  控制缓存 
Connection 连接管理、逐条首部
#### 请求头部
Accept:规定请求可接受的媒体类型,这种内容类型用MIME类型来表示。
```javascript
Accept: text/html

Accept: image/*

```
User-Agent:告诉服务器 客户端使用的操作系统和浏览器.
Content-Type 和 Content-length:
只用于响应头或post请求。content-type表示MIME类型（互联网媒体类型）。
Content-Type：

```javascript
Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data;boundary=something
Content-Type:application/json; charset=utf-8
Content-Type:application/x-www-form-urlencoded
```
![764484130785afb8948fcc5b1ff5cfc7.png](evernotecid://AEB4F5B5-0496-45C8-A67F-414847E50655/appyinxiangcom/25152521/ENResource/p34)

Referer:告诉服务器我是哪个链接过来的
Connection：请求，响应头都有，connection:keep-alive网页打开后，TCP连接不会关闭，如果再访问，会继续使用这个连接。Connection:close 一个request完成后，连接关闭。
If-none-match:传缓存取出的etag。
if-modified-since:传客户端最近更新时间。

响应头部：
Location： 令客户端重定向的URI 
ETag 能够表示资源唯一资源的字符串
Last-Modified 资源最后的修改时间
Access-Control-Allow-Origin/Access-Control-Allow-Headers：
访问服务端资源权限。
set-cookie:设置cookie

#### 状态码
2XX：响应成功类。
3XX：重定向类，完成请求需要进一步处理。
4XX：客户端错误，请求有语法错误或请求无法实现。
5XX：服务器内部错误。

301:永久重定向，表示资源已被分配了新的 URL
302:临时重定向，表示资源临时被分配了新的 URL
304:服务端资源未修改，取缓存资源。
400:请求url语法错误
401:unauthorized 未授权
403:forbidden 表示请求被服务器拒绝。

500:服务器内部错误

### https
#### 定义
可以理解为HTTP+SSL/TLS，即http下加入ssl，https安全基础是ssl，因此加密详细内容就需要ssl，用于安全的http传入。
![67efcbf84219e9d6a02ded1653fbe8b3.png](evernotecid://AEB4F5B5-0496-45C8-A67F-414847E50655/appyinxiangcom/25152521/ENResource/p33)

SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。

TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。

#### 加密算法
1.对称加密

有流式、分组两种，加密和解密都是使用的同一个密钥。
2.哈希算法

将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。

例如：MD5、SHA-1、SHA-2、SHA-256 等

3.非对称加密
* 私钥 + 公钥 = 钥匙对
* 用公钥加密，只能用对应的私钥解密，用私钥加密只能用对应的公钥解密
* 因为通信双方都有自己的密钥对，通信前先把自己的公钥发给对方。

* 然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。
解决方法：
将对称加密的密钥，通过非对称加密公钥（接收方的）加密，发送到接收方，接收方通过私钥解密，得到对称加密的密钥，之后双方通过对成加密沟通。
存在问题：
如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。

解决方案：
这是需要一个第三方的证书（CA），证明发送者身份。
证书包括：
签发者、证书用途、使用者公钥、使用者的HASH算法、证书到期时间，签名等。
问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。
数字签名：
即CA自带hash算法，对证书内容hash加密得到一个摘要，在通过CA私钥加密，得到数字签名。
当别人吧证书发过来时，使用相同的hash算法加密，再把数字签名用公钥解密，得到CA创建的摘要，两个结果一比较就得出中间是否有人篡改了。


#### 总结
1.http是什么样的
http协议基于TCP/IP协议，规定传输内容，头部信息，通过TCP协议进行传输，IP协议进行选址。整个过程没有加密。
2.对称加密
加密解密使用同一个密钥的方式。
问题：
所有客户端都用一个密钥，则破解一个就破解所有用户信息。
每个客户端维护一个密钥，则传输密钥过程中，可能被劫持或篡改。

3.非对称加密
非对称加密会有一对密钥：公钥和私钥。
公钥加密只能用私钥解密，私钥加密只能用公钥解密。

私钥只保存在服务端，公钥可以发送给客户端。

问题：
中间人篡改：
中间人劫持真公钥，并把假公钥发给客户端，客户端发送的信息都会被中间人的假私钥解密。同时中间人可以伪造数据，通过真公钥加密，传给服务端。

解决方法：
第三方认证，数字签名+证书。

数字签名：证书内容hash加密后，通过第三方机构私钥加密。

验证签名时，将签名通过第三方机构公钥解密，客户端再通过hash加密证书内容，对比两个签名，匹配则通过。

如果没有签名，中间人也申请第三方认证，拦截，修改证书信息也无法判断。
中间人可以修改证书信息，但是不能伪造签名，因为需要第三方私钥加密。

流程：
https就是使用ssl/tsl进行加密传输，客户端拿到服务端发送的公钥，通过证书认证，然后客户端随机生成一个对称加密的密钥，通过公钥加密后传给服务端。后续所有信息通过对称加密密钥进行加解密。
#### 最新总结
非对称+对称加密具体步骤：
1.客户端一开始获取非对称加密的公钥，服务端有对应的私钥。
2.客户端生成对称加密私钥，通过非对称公钥加密，传给服务端。
3.服务端用私钥解密后，之后数据都通过对称秘钥加密解密。
整体步骤：
1.客户端向服务端请求证书。
2.服务端将证书返回给客户端，证书包括 证书颁发机构（CA），公钥，网站域名，证书数字签名，hash加密方法等信息。
其中：
* 公钥用来非对称加密，客户端得到公钥，用它加密后传输对称加密秘钥，服务端得到后用私钥解密，之后两端可以通过对称加密秘钥来加密数据。
* 数字签名，通过证书信息hash加密，再经过CA私钥加密得到的。

3.客户端得到证书后，首先在系统里找一致的CA，找到了就把签名通过CA公钥解密，再把证书明文通过hash加密，比较签名跟证书hash加密后的值是否一致。
4.对比结果一致说明没有冒充，可以获取证书中的公钥继续加密。
疑惑解答：
1.中间人有可能篡改该证书吗？
篡改证书后，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法篡改签名，所以签名和证书的比较无法通过。
2.中间人有可能把证书掉包吗？
假设有另一个网站B也拿到了CA机构认证的证书，成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，篡改签名，传给浏览器，这样可以么？
其实是不行的，因为证书里有网站域名，浏览器把证书里网站域名跟自己请求的对比下，就知道是不是被篡改了。
参考：
[看图学HTTPS](https://segmentfault.com/a/1190000014954687)
[面试官（9）：可能是全网最全的http面试答案](https://juejin.im/post/5d032b77e51d45777a126183#heading-13)
[彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231)
[HTTPS系列干货（一）：HTTPS 原理详解](https://zhuanlan.zhihu.com/p/27395037)
[分分钟让你理解HTTPS](https://juejin.im/post/5ad6ad575188255c272273c4)

### http状态码作用
为什么不全用服务端自己定义的code来判断：
1.不能保证服务端健康，如果服务端报错，不能指望他会给你返回正确的状态code。
2.状态码是经过广泛认知的一个标示，使用它避免不同系统code不同带来的理解偏差。
3.浏览器根据状态码会有些特定的操作，比如304.